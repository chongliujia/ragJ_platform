"""
Rust document processor service wrapper.
Tries to load Rust bindings; falls back gracefully if unavailable.
"""

import logging
from typing import List, Dict, Any, Optional
from pathlib import Path

logger = logging.getLogger(__name__)

try:
    # rust_bindings is generated by rust_services/document_processor/build.py
    from rust_bindings import (
        parse_document as _parse_document,
        get_supported_formats as _get_supported_formats,
        extract_metadata as _extract_metadata,
        process_batch_documents as _process_batch_documents,
        clean_text as _clean_text,
        chunk_text as _chunk_text,
        detect_language as _detect_language,
    )
    RUST_AVAILABLE = True
except Exception as e:
    logger.info(f"Rust bindings not available, will use Python fallbacks. Details: {e}")
    RUST_AVAILABLE = False


class RustDocumentProcessor:
    """High-level wrapper for Rust document processing."""

    def __init__(self):
        if not RUST_AVAILABLE:
            raise RuntimeError("Rust document processor not available")

    def parse_file(self, file_path: str, options: Optional[Dict[str, Any]] = None) -> str:
        with open(file_path, "rb") as f:
            content = f.read()
        filename = Path(file_path).name
        return _parse_document(content, filename, options)

    def parse_content(
        self, content: bytes, filename: str, options: Optional[Dict[str, Any]] = None
    ) -> str:
        return _parse_document(content, filename, options)

    def get_metadata(self, file_path: str) -> Dict[str, Any]:
        with open(file_path, "rb") as f:
            content = f.read()
        filename = Path(file_path).name
        return _extract_metadata(content, filename)

    def get_metadata_from_content(
        self, content: bytes, filename: str
    ) -> Dict[str, Any]:
        """Extract metadata directly from in-memory content.

        Mirrors the Rust binding signature extract_metadata(content, filename).
        """
        return _extract_metadata(content, filename)

    def process_batch(
        self, files: List[str], options: Optional[Dict[str, Any]] = None
    ) -> List[str]:
        documents = []
        for file_path in files:
            with open(file_path, "rb") as f:
                content = f.read()
            filename = Path(file_path).name
            documents.append((content, filename))
        return _process_batch_documents(documents, options)

    def clean_and_chunk_text(
        self,
        text: str,
        chunk_size: int = 1000,
        overlap: int = 100,
        clean_options: Optional[Dict[str, Any]] = None,
        chunk_options: Optional[Dict[str, Any]] = None,
    ) -> List[str]:
        cleaned = _clean_text(text, clean_options)
        return _chunk_text(cleaned, chunk_size, overlap, chunk_options)

    def detect_text_language(self, text: str) -> str:
        return _detect_language(text)

    @property
    def supported_formats(self) -> List[str]:
        return _get_supported_formats()


# Global instance (None when Rust is not available)
rust_processor = RustDocumentProcessor() if RUST_AVAILABLE else None
